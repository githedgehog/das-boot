package dynll

import (
	"context"
	"errors"
	"fmt"
	"net/http"
	"sync"

	"go.githedgehog.com/dasboot/pkg/seeder/config"
	"go.githedgehog.com/dasboot/pkg/seeder/server"
	"go.githedgehog.com/dasboot/pkg/seeder/server/generic"
)

type DynLLServer struct {
	done        chan struct{}
	err         chan error
	httpServers map[string]*generic.HTTPServer
}

var _ server.ControlInterface = &DynLLServer{}

func NewDynLLServer(cfg *config.DynLL, handler http.Handler) (*DynLLServer, error) {

	ret := &DynLLServer{
		done:        make(chan struct{}),
		err:         make(chan error, 100),
		httpServers: make(map[string]*generic.HTTPServer),
	}
	// for _, addr := range b.Address {
	// 	if addr == "" {
	// 		return nil, seedererrors.InvalidConfigError("address must not be empty")
	// 	}
	// 	ret.HTTPServers = append(ret.HTTPServers, NewHttpServer(addr, b.ServerKeyPath, b.ServerCertPath, b.ClientCAPath, handler))
	// }
	return ret, nil
}

func (s *DynLLServer) Done() <-chan struct{} {
	return s.done
}

func (s *DynLLServer) Err() <-chan error {
	return s.err
}

func (s *DynLLServer) Start() {
	var wg sync.WaitGroup
	wg.Add(len(s.httpServers))

	for i, hs := range s.httpServers {
		go func(_ string, hs *generic.HTTPServer) {
			hs.Start()
			<-hs.Done()
			// we filter out all ErrServerClosed which are generated by Shutdown or Closed calls
			if err := hs.Err(); err != nil && !errors.Is(err, http.ErrServerClosed) {
				s.err <- fmt.Errorf("server on '%s': %w", hs.Srv().Addr, err)
			}
			wg.Done()
		}(i, hs)
	}

	go func() {
		wg.Wait()
		close(s.done)
		close(s.err)
	}()
}

func (s *DynLLServer) Shutdown(ctx context.Context) error {
	var wg sync.WaitGroup
	var errs []error
	errch := make(chan error, len(s.httpServers))
	wg.Add(len(s.httpServers))

	// fan out shutdown commands to all servers
	for _, hs := range s.httpServers {
		go func(hs *generic.HTTPServer) {
			if err := hs.Shutdown(ctx); err != nil {
				errch <- fmt.Errorf("server on '%s': %w", hs.Srv().Addr, err)
			}
			wg.Done()
		}(hs)
	}

	// collect errors
	done := make(chan struct{})
	go func() {
		for {
			select {
			case err := <-errch:
				errs = append(errs, err)
			case <-done:
				return
			}
		}
	}()

	// wait until all shutdowns have run
	wg.Wait()
	close(done)

	// return accordingly
	if len(errs) == 0 {
		return nil
	} else if len(errs) == 1 {
		return fmt.Errorf("shutdown error: %w", errs[0])
	} else {
		return fmt.Errorf("multiple shutdown errors:\n%w", errors.Join(errs...))
	}
}

func (s *DynLLServer) Close() error {
	var wg sync.WaitGroup
	var errs []error
	errch := make(chan error, len(s.httpServers))
	wg.Add(len(s.httpServers))

	// fan out close commands to all servers
	for _, hs := range s.httpServers {
		go func(hs *generic.HTTPServer) {
			if err := hs.Close(); err != nil {
				errch <- fmt.Errorf("server on '%s': %w", hs.Srv().Addr, err)
			}
			wg.Done()
		}(hs)
	}

	// collect errors
	done := make(chan struct{})
	go func() {
		for {
			select {
			case err := <-errch:
				errs = append(errs, err)
			case <-done:
				return
			}
		}
	}()

	wg.Wait()
	close(done)

	// return accordingly
	if len(errs) == 0 {
		return nil
	} else if len(errs) == 1 {
		return fmt.Errorf("close error: %w", errs[0])
	} else {
		return fmt.Errorf("multiple close errors:\n%w", errors.Join(errs...))
	}
}
